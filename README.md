# JS_Math_operation  


### Как вы понимаете определения: унарный, бинарный, операнд??

**Операнд** – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда:  
левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».  
**Унарным** называется оператор, который применяется к одному операнду. Например,  
оператор унарный минус "-" меняет знак числа на противоположный  
**Бинарным** называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме  

Большинство операторов в JavaScript возвращают значение. Для некоторых это очевидно, например сложение + или умножение *.   
Но и оператор присваивания не является исключением. Вызов x = value записывает value в x и возвращает его.  

**Что такое = ? (Оператор присваивания)**
 присваивает значение правого операнда  
 Присваивание = возвращает значение
 
**Объясните разницу между инкрементом перед выражением и после него?**

Инкремент ++/декремент --    
Когда оператор идёт после переменной — это «постфиксная форма»: counter++.  
«Префиксная форма» — это когда оператор идёт перед переменной: ++counter.  
 Префиксная форма возвращает новое значение,  
 в то время как постфиксная форма возвращает старое (до увеличения/уменьшения числа).

**Расскажите о сокращённой арифметике присваивания (+=, -=)?** 
(+=) добавляем значение правого операнда к переменной и присваиваем переменной результат  

**Из чего состоит цикл for (?, ?, ?) ?**  
 for (начало; условие; шаг)   
 
**Break / continue - это?**  
break прерывает выполнение текущего цикла, переключателя switch,  
Инструкция continue прерывает выполнение текущей итерации текущего или  
отмеченного цикла, и продолжает его выполнение на следующей итерации. 

### Операторы сравнения

https://learn.javascript.ru/comparison

Оператор строгого равенства === проверяет равенство без приведения типов.  

Операторы сравнения возвращают значения логического типа.  
Строки сравниваются посимвольно в лексикографическом порядке.  
Значения разных типов при сравнении приводятся к числу. Исключением является сравнение с помощью операторов строгого равенства/неравенства.  
Значения null и undefined равны == друг другу и не равны любому другому значению.  
Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, которые могут принимать значения null/undefined. Хорошей идеей будет сделать отдельную  проверку на null/undefined.

**Объясните проблему сравнения с помощью (==)?**
Этот оператор проверяет равенство с приведения типов.
    
**Как решает эту проблему оператор строгого равенства (===)?**
Этот оператор проверяет равенство без приведения типов.


**Cуществуют базовые опраторы, опер сравнения  и лог операторы**


### Что такое if, else,else if и тернарный оператор  

Инструкция if(...) вычисляет условие в скобках и, если результат true, то выполняет блок кода.

```
if (year == 2015) alert( 'Вы правы!' );
```

Инструкция if (…) вычисляет выражение в скобках и преобразует результат к логическому типу.

**Преобразование типов:**  
Число 0, пустая строка "", null, undefined и NaN становятся false.  
Остальные значения становятся true


### Логические операторы

**В JavaScript есть три логических оператора: || (ИЛИ), && (И) и ! (НЕ).**

**Оператор «ИЛИ»**
```
result = a || b;
```
ИЛИ «||» находит первое истинное значение 

Оператор || выполняет следующие действия:  
Вычисляет операнды слева направо.  
Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.  
Если все операнды являются ложными (false), возвращает последний из них.  
Значение возвращается в исходном виде, без преобразования.  
цепочка ИЛИ "||" возвращает первое истинное значение или последнее, если такое значение не найдено.

**Оператор И**
```
result = a && b;
```

Оператор && выполняет следующие действия:

Вычисляет операнды слева направо.  
Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.  
Если все операнды были истинными, возвращается последний.  
Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено.

Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое ложное значение, а ИЛИ –  первое истинное.

**Оператор НЕ  !**
```
result = !value;
```
Оператор принимает один аргумент и выполняет следующие действия:  
Сначала приводит аргумент к логическому типу true/false.  
Затем возвращает противоположное значение.

## Циклы while и for и Конструкция "switch"  и Break / continue  

**Циклы** - способ сделать действие несколько раз.  
Одно выполнение тела цикла по-научному называется **итерация**


### цикл for (?, ?, ?) **
```
// for (начало; условие; шаг) {
//   // ... тело цикла ...
// }
```
начало	i = 0	Выполняется один раз при входе в цикл  
условие	i < 3	Проверяется перед каждой итерацией цикла. Если оно вычислится в false, цикл остановится.  
шаг	i++	  Выполняется после тела цикла на каждой итерации перед проверкой условия.  
тело alert(i)	Выполняется снова и снова, пока условие вычисляется в true.


### Конструкция "switch"

Конструкция switch заменяет собой сразу несколько if.  
 Конструкция switch имеет один или более блок case и необязательный блок default.
```
switch(x) {
    case 'value1':  // if (x === 'value1')
     ...
     [break]

    case 'value2':  // if (x === 'value2')...
      [break]

   default:
     ...
      [break]
  }
```
Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее.  
Если соответствие установлено – switch начинает выполняться от  
соответствующей директивы case и далее, до ближайшего break (или до конца switch).  
Если ни один case не совпал – выполняется (если есть) вариант default.

### Чем отличается while от do while?
```
 while (condition) {     // код
//     // также называемый "телом цикла"
//   }
// Код из тела цикла выполняется, пока условие condition истинно.

// do {
//     // тело цикла
//   } while (condition);
```
Цикл сначала выполнит тело, а затем проверит условие condition, и пока его значение равно true, он будет выполняться снова и снова.
